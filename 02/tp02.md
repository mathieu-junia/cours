# Worklab 2: Setup of the backend project, connect it to the frontend and setup the repository

- [Worklab 2: Setup of the backend project, connect it to the frontend and setup the repository](#worklab-2-setup-of-the-backend-project-connect-it-to-the-frontend-and-setup-the-repository)
  - [Setup of the REST API Helloworld](#setup-of-the-rest-api-helloworld)
    - [The Helloworld of REST API](#the-helloworld-of-rest-api)
      - [As part of the URL path](#as-part-of-the-url-path)
      - [As a query parameter](#as-a-query-parameter)
    - [FastAPI and Pydantic](#fastapi-and-pydantic)
    - [Writing the documentation of the API with OpenAPI/Swagger](#writing-the-documentation-of-the-api-with-openapiswagger)
      - [Redirection to the documentation](#redirection-to-the-documentation)
      - [Why should we use a REST layer ?](#why-should-we-use-a-rest-layer-)
        - [Rate limiter](#rate-limiter)
        - [Security](#security)
    - [Connect FastAPI and Ollama](#connect-fastapi-and-ollama)
    - [Connect FastAPI and the frontend](#connect-fastapi-and-the-frontend)
  - [Setup the repository](#setup-the-repository)
  - [Setup the github actions](#setup-the-github-actions)
  - [To go further: LiteLLM](#to-go-further-litellm)


## Setup of the REST API Helloworld

We will use [FastAPI](https://fastapi.tiangolo.com/) to build our REST API backend. FastAPI is a modern, high-performance web framework for building APIs with Python 3.7+.

Its key features are:

* **Speed**:
  * **Leverages ASGI** (Asynchronous Server Gateway Interface) for high concurrency and performance.
  * Significantly faster than many other Python frameworks.
* **Developer Experience**:
  * **Type hints**: Utilizes Python's type hints for automatic data validation and clear code documentation.
  * **Automatic interactive API documentation**: Generates interactive API documentation (using OpenAPI/Swagger) with minimal effort. This makes it easy for developers to understand and use your API.
  * **Asynchronous support**: Enables efficient handling of multiple requests concurrently, improving overall performance and responsiveness.
* Ease of Use:
  * **Concise and intuitive syntax**: Easy to learn and use, even for beginners.
  * Dependency injection: Simplifies code organization and testing.
* **Production Ready**:
  * **Robust and battle-tested**: Designed for production environments with features like dependency injection, data validation, and security considerations.

In essence, FastAPI aims to:

  * **Increase development speed**: By reducing the time spent on writing boilerplate code and debugging.
  * **Improve code quality**: Through type hints and automatic data validation.
  * **Enhance developer experience**: With excellent documentation and a user-friendly interface.

Key Use Cases:

  * **Building RESTful APIs**: For various applications, including web services, microservices, and machine learning models.
  * **Creating backend services**: For web applications, mobile apps, and other client-side applications.

All the REST APIs and backend we deploy in production are developped using FastAPI. It's an excellent choice, the documentation is quite good and community is large, so you won't have trouble to find answers to your questions.

Let's create a new project for our backend.

* `mkdir backend`
* `cd backend`
* `uv init --app --python 3.12`

We will need the 4 following libraries: fastapi, uvicorn, httpx, pydantic. So let's add them to the project.

* `uv add fastapi pydantic httpx uvicorn`.

You already know `pydantic` and `httpx` from the previous worklab, `uvicorn` is a web server implementation for Python. It's uvicorn that allows fastapi to run.

Again, we will also add `ruff` and `isort` as dev dependencies.

* `uv add isort ruff --dev`

Before jumping into the REST API that will communicate with Ollama. Let's build a simple helloworld REST API.

### The Helloworld of REST API

In the backend directory, create a `main.py` file and write the following code in it.

```py
from fastapi import FastAPI, status


app = FastAPI(title="JuniaGPT", version="1.0.0")

@app.post(
    "/helloworld",
    tags=["helloworld"],
    status_code=status.HTTP_200_OK,
)
def post_hellowolrd() -> dict:
    """the easiest rest api."""
    return {"hello": "world"}
```
This is the simplest REST API you can write. It has a single endpoint `/helloworld` which allows you to a `POST` request, and it returns the following dict in json format `{"hello": "world"}`.

`app = FastAPI(title="JuniaGPT", version="1.0.0")` is the main part of the code, this is this part which defines the FastAPI REST API, you can change the title to your liking, the version should follows the [semantic versioning](https://semver.org/) conventions.

The fact that you have defined an endpoint with to a `POST` request is defined by the following decorator

```py
@app.post(
    "/helloworld",
    tags=["helloworld"],
    status_code=status.HTTP_200_OK,
)
```
`@app.post` will define a `POST` request, `@app.get` will define a `GET` request and so on. Inside you have to define the value of the endpoint, here `"/helloworld"`, some tags (optional) which helps grouping requests, and a `status_code` which defines the standard [status code](https://developer.mozilla.org/fr/docs/Web/HTTP/Status) the endpoint should return if there are no errors.

You can see the full list of parameters of the `FastAPI` class [here](https://fastapi.tiangolo.com/reference/fastapi/#fastapi.FastAPI).

To see you app running, you can use one of the two following commands.

* `uv run uvicorn main:app --host 0.0.0.0 --port 8000 --reload` or
* `uvicorn main:app --host 0.0.0.0 --port 8000 --reload` if you have activated your virtual environment (remember why you need to activate it ?)

The following `curl` command will show that your api is up and running.

* `curl -X 'POST' 'http://0.0.0.0:8000/helloworld'`

Let's pimp a little bit our endpoint. We now want it to return `{"hello": "world"}` but with an extra parameter, like a name, so we want it to return for example `{"hello": "world by Mathieu"}`. There are two ways to do that: as part of the URL path, or as a query parameter.

#### As part of the URL path

To do that, update your code as the following one.


```py
from fastapi import FastAPI, status


app = FastAPI(title="JuniaGPT", version="1.0.0")

@app.post(
    "/helloworld/names/{name}",
    tags=["helloworld"],
    status_code=status.HTTP_200_OK,
)
def post_hellowolrd(name:str) -> dict:
    """the easiest rest api."""
    return {"hello": f"world by {name}"}
```

#### As a query parameter

To do that, update your code as the following one.


```py
from fastapi import FastAPI, status


app = FastAPI(title="JuniaGPT", version="1.0.0")

@app.post(
    "/helloworld/",
    tags=["helloworld"],
    status_code=status.HTTP_200_OK,
)
def post_hellowolrd(name:str) -> dict:
    """the easiest rest api."""
    return {"hello": f"world by {name}"}
```

The difference between the two lies in the URL, for the first one you have `"/helloworld/names/{name}"` so the name is part of the URL and to call this endpoint you have to a request like the following one.

* `curl -X 'POST' 'http://0.0.0.0:8000/helloworld/names/Mathieu'`

While in the latter case, this is defined a query parameter, so the request will look like the following one.

* `curl -X 'POST' 'http://0.0.0.0:8000/helloworld/?name=Mathieu'`

Query parameters are always identified by the pattern `?key=value` in urls.

Which one is the best ? The best practice for RESTful API design is that **path parameters** are used to **identify a specific resource or resources**, while **query parameters** are used to **sort/filter those resources**, [source](https://stackoverflow.com/questions/30967822/when-do-i-use-path-parameters-vs-query-parameters-in-a-restful-api). Since here we clearly are not sorting or filtering anything, we can stick with the URL path base approach.

### FastAPI and Pydantic

When you need to send data from a client (let's say, a browser) to your API, you send it as a request body.

A request body is data sent by the client to your API. A response body is the data your API sends to the client.

Your API almost always has to send a response body. But clients don't necessarily need to send request bodies all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body.

To declare a **request body**, you use Pydantic models with all their power and benefits. [source](https://fastapi.tiangolo.com/tutorial/body/)

Request Bodies are mainly used in the case of `POST` requests, as we will see in the section wehre we connect the api to Ollama.

### Writing the documentation of the API with OpenAPI/Swagger



#### Redirection to the documentation

When your api is up and running, you can access its documentation in the OpenAPI/Swagger format at the address `0.0.0.0:8000/docs`, or `localhost:8000/docs` depending on your browser. Since we are lazy and we do not want to type the `/docs` part, we add a direction redirection to the doc as soon as we type `0.0.0.0:8000`. You can do this by adding the following piece of code to your  `main.py` file.

```py
from starlette.responses import RedirectResponse

@app.get(
    "/",
    tags=["startup"],
    description="API startup on documentation page.",
)
def main():
    """Redirect to the api documentaiton at launch."""
    return RedirectResponse(url="/docs")
```


#### Why should we use a REST layer ?
##### Rate limiter
##### Security

### Connect FastAPI and Ollama

### Connect FastAPI and the frontend

## Setup the repository

## Setup the github actions

## To go further: LiteLLM